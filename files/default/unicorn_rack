#!/usr/bin/env ruby

require 'sys/proctable'
require 'etc'
require 'json'

$0 = File.expand_path($0)

ENV["PATH"] = "/usr/local/bin:/usr/local/bin:#{ENV["PATH"]}"

def get_apps
  JSON.load(File.read("/etc/default/unicorn.json"))
end

pids = Sys::ProcTable.ps.select { |x| x.cmdline =~ /^unicorn/ && x.ppid == 1 }

app = ARGV[1]
if app
  pid = pids.find { |x| x.cmdline =~ /#{Regexp.quote app}/ }

  if pid
    pids = [pid]
  else
    pids = []
  end
end

case ARGV[0]
when "restart"
  system("#{Gem.ruby} #{$0} stop #{app}")
  system("#{Gem.ruby} #{$0} start #{app}")
when "reload"
  pids.each do |pid|
    puts "reloading '#{pid.cmdline}'"
    Process.kill(:USR2, pid.pid)
    sleep 1
    Process.kill(:QUIT, pid.pid)
  end
when "start"
  apps = get_apps
  if app
    apps = { app => apps[app] }
  end

  unless apps.keys.size > 0
    raise ArgumentError, "Could not find any applications; aborting" 
  end

  apps.each do |key, value|
    puts "Attempting to start '#{key}'"
    fork do
      user = Etc.getpwnam("rails")
      Process.uid = user.uid
      Process.gid = user.gid
      Process.euid = user.uid
      Process.egid = user.gid
      Dir.chdir(key) do
        exec("bundle exec '#{value["bin"]}' -c '#{value["config_path"]}' -E production -D")
      end
    end
  end
when "stop"
  pids.each do |pid|
    puts "stopping '#{pid.cmdline}'"
    Process.kill(:INT, pid.pid)
  end
end
